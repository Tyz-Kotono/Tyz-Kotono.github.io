- 在游戏开发中，节点之间的数据传递是至关重要的。每种数据传递方式都有其特定的优劣势，适合不同场景的需求。根据你的需求，我们可以比较以下五种数据传递方法：

  1. **单字典缓冲**：通过全局的字典（`Dictionary`）存储每个 `Edge` 或 `Connection` 的数据。
  2. **双字典缓冲**：使用两个字典分别存储 `Port` 和 `Edge` 之间的数据，提供更多的灵活性。
  3. **广播-订阅模式（Observer/Subscriber Pattern）**：节点通过广播和订阅来传递和接收数据。
  4. **节点自身保存数据**：每个节点直接存储并传递自己的数据，而无需依赖外部存储。
  5. **连接（`Edge`）存储数据**：将数据存储在连接（`Edge`/`CodeGraphConnection`）中，并通过连接管理数据传递。

  我们将分别讨论这些方法的工作机制、优缺点，并总结出在频繁数据传递场景下哪种方式更为适合。

  ------

  ### 1. **单字典缓冲**

  #### 机制：

  - 使用单个全局字典（`Dictionary<string, object>`）来存储所有 `Edge` 的数据，键为 `Edge` 的 GUID。
  - 每个节点在处理时，从字典中获取数据，处理后再更新字典中的值。

  #### 优势：

  - **简单易实现**：只有一个全局字典管理所有连接的数据，逻辑简单。
  - **数据集中**：所有数据都存储在一个地方，便于管理和检索。

  #### 劣势：

  - **容易引起冲突**：因为数据都是全局存储的，多个节点或连接同时访问字典时容易出现数据覆盖或竞争问题。
  - **性能瓶颈**：当数据量较大且频繁访问时，字典的查找、更新操作可能会成为性能瓶颈。

  ------

  ### 2. **双字典缓冲**

  #### 机制：

  - 使用两个字典：一个字典存储节点的 `Port` 数据，另一个字典存储 `Edge` 数据。
  - 数据传递时，`Port` 数据会通过 `Edge` 传递给目标节点的 `Port`。

  #### 优势：

  - **灵活性更强**：双字典的设计能够更细致地管理数据传递，特别适合复杂的数据流动。
  - **数据追踪**：可以更精确地追踪 `Port` 和 `Edge` 之间的数据流动，便于调试和管理。

  #### 劣势：

  - **复杂性增加**：相较于单字典，双字典的实现复杂度更高，需要管理多个字典的数据同步。
  - **内存占用更大**：需要维护两套字典，增加了内存使用。

  ------

  ### 3. **广播-订阅模式（Observer/Subscriber Pattern）**

  #### 机制：

  - 节点使用广播机制将数据发布出去，其他节点通过订阅特定的事件或数据来接收。
  - 事件驱动机制，节点在特定事件发生时自动处理数据。

  #### 优势：

  - **解耦性强**：节点之间的耦合度降低，订阅者无需知道数据源的具体实现，数据发布者也无需管理订阅者。
  - **动态性好**：广播-订阅模式支持动态添加或移除订阅者，适合灵活的系统设计。

  #### 劣势：

  - **调试困难**：数据流动过程是异步的，事件传播路径不明显，调试时很难追踪。
  - **潜在性能问题**：如果广播频率过高，特别是多个节点同时广播时，可能会引发性能问题。

  ------

  ### 4. **节点自身保存数据**

  #### 机制：

  - 每个节点自己保存输入和输出的数据。数据从一个节点传递到另一个节点时，节点直接从自身的数据存储中提取数据进行处理。

  #### 优势：

  - **数据就近存储**：节点的数据与节点逻辑紧密结合，存储与操作都在同一处完成，降低了数据传递的复杂性。
  - **高效**：因为数据始终由节点自身管理，所以减少了对外部数据结构的依赖，访问速度更快。

  #### 劣势：

  - **难以跨节点访问**：如果需要跨多个节点传递数据，可能需要在每个节点中实现冗余的访问逻辑。
  - **数据同步问题**：多个节点之间的数据依赖可能导致数据同步困难。

  ------

  ### 5. **连接（`Edge`）存储数据**

  #### 机制：

  - 每个 `Edge` 或 `Connection` 负责存储其传递的数据。数据流动时，数据从一个连接传递到下一个节点的输入端口。

  #### 优势：

  - **清晰的数据流**：每个连接负责自己的数据存储和传递，数据流动路径更加直观和清晰。
  - **适合复杂连接**：当有多个节点通过 `Edge` 连接时，这种方式有助于简化节点之间的数据传递。

  #### 劣势：

  - **数据分散管理**：数据分散在不同的连接上，管理和调试相对困难，特别是对于复杂的图表结构。
  - **内存开销**：每个连接都需要存储自己的数据，可能增加内存占用。

  ------

  ### 场景比较：频繁数据传递

  在频繁的数据传递场景中，需要考虑数据传递的效率、同步问题以及系统复杂性。以下是这些方法在频繁数据传递场景中的适用性。

  | 传递方法                   | 机制特点                         | 优势                                           | 劣势                                         | 适合场景                                                     |
  | -------------------------- | -------------------------------- | ---------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------ |
  | **单字典缓冲**             | 全局字典统一存储 `Edge` 数据     | 实现简单，数据集中，便于管理                   | 数据竞争问题，性能瓶颈，无法支持复杂的数据流 | 适用于小规模项目或数据传递较简单的场景                       |
  | **双字典缓冲**             | 分别存储 `Port` 和 `Edge` 的数据 | 灵活性强，支持复杂的节点连接，适合复杂的数据流 | 实现复杂，内存占用更大                       | 适用于需要精确管理 `Port` 和 `Edge` 数据的复杂图表，适合中到大型项目，数据传递频繁且复杂的场景 |
  | **广播-订阅模式**          | 事件驱动，节点通过订阅接收数据   | 解耦性强，节点之间独立工作，动态性强           | 难以调试，频繁广播可能带来性能问题           | 适合复杂的异步系统或需要动态添加/删除订阅者的场景，不适合数据传递频繁的高实时性场景 |
  | **节点自身保存数据**       | 节点自己管理输入和输出数据       | 数据就近存储，效率高                           | 跨节点数据传递复杂，数据同步困难             | 适合独立性较强的节点逻辑，数据流简单，节点间依赖较少的场景   |
  | **连接（`Edge`）存储数据** | 每个连接管理自己的数据           | 数据流动路径清晰，适合复杂连接的数据传递       | 数据分散，管理复杂，增加内存占用             | 适合数据流复杂的图表，多个 `Edge` 连接的场景。特别适合需要频繁传递数据并且需要追踪数据路径的场景，如图表编辑器或复杂任务调度系统 |

  ------

  ### 结论与建议：

  **频繁数据传递场景的推荐方案：**

  - **双字典缓冲** 和 **连接（`Edge`）存储数据** 是较为推荐的两种方式：
    - **双字典缓冲** 适合复杂的数据流管理，能够对节点 `Port` 和 `Edge` 的数据进行精准控制，适合需要在频繁数据传递中保持高效且灵活的数据结构。
    - **连接（`Edge`）存储数据** 更适合需要追踪数据传递路径的场景，它提供了更加直观的方式来管理节点之间的数据流，同时保留了一定的灵活性。
  - **节点自身保存数据** 更适合数据流较简单的场景。对于高度依赖节点间频繁数据传递的系统，它的灵活性不足。
  - **单字典缓冲** 实现较为简单，但在数据流动复杂时难以满足性能需求。
  - **广播-订阅模式** 虽然解耦性好，但在频繁数据传递中，可能带来性能问题，且调试困难。

  对于你需要**频繁数据传递**的场景，推荐使用 **双字典缓冲** 或 **连接（`Edge`）存储数据** 作为主要的数据传递方式。

#### Unity 和 UE



Unity 的 **Bolt**（现在叫做 **Unity Visual Scripting**）和 Unreal Engine 的 **蓝图（Blueprints）** 在数据传递和节点系统的设计上有一些相似之处，但也有各自的特点。我们可以通过对比它们的工作机制来了解它们是如何传递数据的，以及它们最接近哪种数据传递方式，进而寻找更好的解决方案。

##### Unity Bolt 的数据传递方式

#### 工作机制：

Unity Bolt 使用的是一种 **“节点-连接”** 的数据流模型。节点通过连接线（`Edge`）来传递数据，节点之间的输入和输出端口是数据流动的关键。每个连接线类似于我们讨论的 `Edge`，通过这些连接线，数据从一个节点流向另一个节点。

在 Unity Bolt 中，每个节点有自己的输入和输出端口，每条连接线也会携带相关的数据。在运行时：

- **节点处理**：节点执行其逻辑并生成输出。
- **连接传递**：输出通过连接线传递到下一个节点的输入端口。
- **数据流**：数据会沿着连接线传递到相应的节点。

#### 接近的数据传递方式：

- **连接（`Edge`）存储数据**：Bolt 更接近这种方式，因为数据是在节点之间的连接上流动。每个连接线存储并传递数据，类似于我们讨论的 `Edge` 存储数据的方法。
- **节点自身保存数据**：每个节点存储输入和输出端口的数据，这些数据会在执行时从连接线获取和处理。节点在执行完成后也可以保存自己的状态。

#### 优势：

- **灵活性**：这种方式允许任意复杂的数据流，可以通过端口和连接线来清晰地追踪数据的传递路径。
- **可视化**：Bolt 的数据流动是可视化的，用户可以看到每个节点之间的连接，知道数据如何流动。

#### 劣势：

- **性能**：在数据流动非常频繁的场景中，Bolt 的性能可能会受到影响，特别是大量节点和连接的场景下，数据传递的效率可能会下降。
- **复杂性**：如果节点图表过于复杂，管理和维护会变得困难，特别是在数据调试时，随着节点的增多，追踪数据流动的路径可能变得复杂。

### Unreal Engine 蓝图的方式

#### 工作机制：

Unreal Engine 的蓝图系统与 Unity Bolt 有很多相似之处。它也是基于节点的系统，节点通过 **执行流（Execution Flow）** 和 **数据流（Data Flow）** 来进行数据传递和逻辑执行。

- **执行流**：类似于传统的代码控制流，蓝图通过执行流控制节点的顺序。每个节点可以是一个函数、事件或动作，执行流控制数据流动的顺序。
- **数据流**：数据通过连接线（Pin）在节点之间流动，每个连接线会携带节点之间传递的数据。

蓝图系统有良好的 **可视化表现**，可以非常清晰地看到数据是如何在节点之间流动的。与 Bolt 一样，蓝图系统中的数据存储在节点的输入和输出连接线上，并通过这些连接线传递。

#### 接近的数据传递方式：

- **连接（`Edge`）存储数据**：蓝图与 Bolt 类似，也是通过连接线（Pin）来传递数据。因此，它的机制最接近 **连接存储数据** 的方式。
- **节点自身保存数据**：每个节点可以保存自己的状态和数据，允许节点之间进行数据传递和共享。

#### 优势：

- **高度可视化**：蓝图提供了非常直观的图表界面，允许开发者清晰地看到数据流和逻辑流动的路径。
- **灵活的控制流**：蓝图允许开发者对执行流进行精确的控制，提供了极高的灵活性。

#### 劣势：

- **性能问题**：类似于 Bolt，蓝图在大规模、复杂的图表中，数据传递的效率可能会成为瓶颈，特别是在实时计算频繁发生的场景中。

------

### 数据传递方式的比较

我们可以将上面几种数据传递方式与 Unity Bolt 和 Unreal Engine 蓝图进行对比，找到更适合你需求的方式：

| **传递方式**                  | **机制特点**                                 | **Bolt 的相似性**                           | **蓝图的相似性**                        | **优劣**                                                     |
| ----------------------------- | -------------------------------------------- | ------------------------------------------- | --------------------------------------- | ------------------------------------------------------------ |
| **单字典缓冲**                | 全局字典存储 `Edge` 数据                     | Bolt 不使用单字典，数据流由节点和连接线管理 | 蓝图不使用全局字典，数据在节点之间传递  | **优点**：简单、统一管理 **缺点**：频繁数据访问时会有性能瓶颈，全局字典容易产生竞争问题 |
| **双字典缓冲**                | 分别存储 `Port` 和 `Edge` 数据               | Bolt 没有明确的双字典管理                   | 蓝图也没有双字典概念                    | **优点**：灵活、支持复杂数据流 **缺点**：管理复杂，内存开销较大 |
| **广播-订阅模式（Observer）** | 节点通过事件发布数据，其他节点通过订阅接收   | Bolt 不使用广播订阅机制                     | 蓝图不直接使用广播-订阅模式             | **优点**：解耦性强、灵活 **缺点**：数据流异步传递，调试困难，频繁广播可能造成性能问题 |
| **节点自身保存数据**          | 节点管理自己的输入和输出，数据存储在节点本地 | Bolt 节点存储输入/输出端口的数据            | 蓝图节点也存储自己的输入/输出数据       | **优点**：简单、高效 **缺点**：跨节点数据传递困难，数据同步问题可能比较复杂 |
| **连接存储数据**              | 数据存储在连接上，通过 `Edge` 传递           | **Bolt 采用这种方式**，通过连接线传递数据   | **蓝图也是这种方式**，数据通过 Pin 传递 | **优点**：数据流路径清晰，适合复杂图表 **缺点**：管理复杂，特别是当数据存储在连接线时，过多的连接线可能导致内存开销大且难以维护 |

------

### 更好的方式：参考 Unreal 蓝图和 Bolt 的经验

在参考 Unity Bolt 和 Unreal Engine 蓝图的经验后，我们可以得出以下改进建议：

1. **结合 `连接存储数据` 与 `节点自身保存数据`**：
   - 让节点能够保存它的内部状态和局部数据，同时通过连接线传递共享数据。这种方式可以平衡节点的独立性和数据传递的灵活性。
   - 使用连接线传递数据的方式清晰直观，并且适合在图形化的节点系统中直观展示数据流动的路径。
2. **引入缓存和优化数据流动**：
   - 对于频繁的数据传递场景，可能引入数据缓存机制，以避免重复的计算和数据传递。
   - 可以通过 `双字典缓冲` 的方式来管理节点和连接线的数据，从而优化复杂场景下的数据流动效率。
3. **事件驱动的数据流补充**：
   - 可以考虑在节点系统中引入事件驱动的机制，让某些特殊节点通过广播事件通知其他节点进行特定的计算或更新。这可以与常规的连接存储数据机制结合使用，以提高系统的灵活性。

------

### 总结

- **Unity Bolt 和 Unreal Engine 蓝图** 都主要采用 **连接存储数据** 的方式，数据通过连接线在节点之间流动。
- **连接存储数据** 是适合复杂图表系统的方式，因为它可以清晰地展示数据流动路径，并允许复杂的节点依赖和数据传递。
- 如果你需要更好地优化数据传递，建议结合 **节点自身保存数据** 与 **连接存储数据** 的方式，这样可以让每个节点既管理自己的状态，也能通过连接来传递数据，达到高效和灵活的平衡。





#### 4、源代码生成器

来简化每个Node之间端口的 DataLink去节省时间





